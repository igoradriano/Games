package graficos3;

import java.awt.Dimension; 
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.image.BufferStrategy;
import java.awt.image.BufferedImage;
import javax.swing.JFrame;  
import java.awt.Canvas;    
import java.awt.Color;

public class Game extends Canvas implements Runnable{  //Classe Game com Interface Runnable
	
	public static JFrame frame;  //declarando frame do tipo JFrame
	private final int  WIDTH = 240; //declarando constante WIDTH com seu valor
	private final int HEIGTH = 160;
	private final int SCALE = 3;
	private Thread thread;  //declarando thread
	private boolean isRunning = true;  
	private BufferedImage image;
	private Spritesheet sheet;
	private BufferedImage[] player;
	private int frames = 0;
	private int maxframes = 5;  //de quantos em quantos frames quero que anime meu personagem
	private int curAnimation = 0, maxAnimation = 4;  //maxAnimation é número máximo de animções(imagens)
	private int x;
	
	public Game() {   //Método Construtor	
		sheet = new Spritesheet("/spritesheet.png");
		player = new BufferedImage[4];
		player[0] = sheet.getSprite(0, 0, 16, 16);
		player[1] = sheet.getSprite(16, 0, 16, 16);
		player[2] = sheet.getSprite(32, 0, 16, 16);
		player[3] = sheet.getSprite(48, 0, 16, 16);
		this.setPreferredSize(new Dimension(WIDTH*SCALE,HEIGTH*SCALE));  //criando Janela passando as constantes como parâmetro
		initFrame(); //chamando método init abaixo
		image = new BufferedImage(WIDTH,HEIGTH,BufferedImage.TYPE_INT_RGB); //largura,altura,typo
	}
	public void initFrame() {
		frame = new JFrame("Janela do Igor");   //instanciando JFrame
		frame.add(this);  //'this' se refere ao Canvas, no caso a linha de cima, this.setPreferenceSize
		frame.setResizable(false); //Não quero que usuário consiga redimensionar a Janela
		frame.pack(); //método do frame para depois que adicionar o canvas, calcular certo as dimensoes e mostrar
		frame.setLocationRelativeTo(null);  //abre no centro da tela
		frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); //Chamando método frame dizendo que quando clicar eu quero que de fato feche sem continuar executando o programa.
		frame.setVisible(true);  //Quando inicializar ja está visível
		
	}
	public synchronized void start() { //método start que será chamado pelo objeto game
		thread = new Thread(this);   //Essa classe game vai como parâmetro no thread
		isRunning = true; //por padrão é false
		thread.start();  //Duas threads estão sendo executadas simultaneamente: a thread atual (que retorna da chamada para o método start) e a outra thread (que executa seu método run). 
		
	}
	public synchronized void stop() {
		isRunning= false;
		try {
			thread.join();
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	public static void main(String[] args) {
		Game game = new Game(); 
		game.start();	
	}
	
	public void tick() {
		frames++; 	
		if (frames > maxframes) {
			frames = 0;
			curAnimation++;
			if(curAnimation >= maxAnimation) { //depois o curAnimation é passado cmo parâmetro do player g2
				curAnimation = 0;
			}
		}
		x+=20;
	}
	
	public void render() {
		BufferStrategy bs = this.getBufferStrategy(); //BufferStrategy é uma sequencia de buffers para utilizar na renderização
		if(bs == null) {
			this.createBufferStrategy(3);
			return; //funciona como um break
		}
		Graphics g = image.getGraphics();
		g.setColor(new Color(0,0,150)); //RGB 
		g.fillRect(0, 0,WIDTH,HEIGTH);
		//2 linhas acima são sempre obrigatórias para renderização. Basicamente apaga o que tinha na tela antes e renderiza novamente;
		//Colocando um retangulo da cor que eu quero
		
		/*RENDERIZAÇÃO do JOGO*/
		Graphics2D g2 = (Graphics2D) g; //(Graphics2D) é um cast . Agora tenho um objeto 2d sendo igual a variável g to tipo Graficos.
		//g2.rotate(Math.toRadians(45),90+8,90+8); //+8 pois a imagem tem 16 px, aidiconando 8 a cada coordenada, consigo o meio da imagem
		g2.drawImage(player[curAnimation], x, 50,null); //Boneco imagem
		//g2.rotate(Math.toRadians(-45),90+8,90+8);
		g2.setColor(new Color(0,0,0,100)); //colocar uma layer de outra cor
		g2.fillRect(0, 0, WIDTH, HEIGTH);
		
		
		/***/
		g.dispose();//limpar dados que tem na imagem que foram utilizados antes
		g.setColor(Color.cyan); // setando cores de outro objeto
		g.fillRect(10, 0, 10, 10);  //renderizando outro retangulo (pos_x,pos_y,tam_x,tam_y)
		g.setColor(Color.gray); 
		g.fillRect(20, 20, 20, 20); 
		g.setColor(Color.green); 
		g.fillRect(40, 40, 30, 30);  
		g.setColor(Color.red); 
		g.fillRect(80, 80,80, 40);  
		g.setColor(Color.yellow); 
		g.fillOval(100, 10, 30,30);  //CIRCULAR
		g.setFont(new Font("Arial", Font.BOLD, 10)); //font, style, tamanho
		g.drawString("Olá Mundo", 20, 20);  //RENDERIZANDO STRING
		g = bs.getDrawGraphics();
		g.drawImage(image,0,0,WIDTH*SCALE,HEIGTH*SCALE,null);
		bs.show();
	}
	public void run() {	 //método run deve ser chamado na execução do thread.start() dentro do método start da classe;
		long lastTime = System.nanoTime(); //tempo atual do pc em nano segundos
		double amoutOfTicks = 60.0; // quantidade de frames desejadas 
		double ns = 1000000000 / amoutOfTicks;   // período dos frames (1s/60 frames) = 60fps, porém está em nano seundos
		double delta = 0;  //declarando delta, diferença entre frames atuais e do tempo anterior
		int frames = 0;   //declarando quantidade de frames
		double timer = System.currentTimeMillis(); //declarando tempo em milisegundos
		while(isRunning) {  
			long now = System.nanoTime();  //recebo o tempo atual
			delta+= (now - lastTime) / ns;   //diferença do tempo anterior menos o atual / período
			lastTime = now; //tempo atual vira tempo passado
			if (delta >= 1) { // quando o somatório dos  deltas der igual a 1 faça:
				tick();   
				render();
				frames ++; 
				delta --;
				
			}
			if (System.currentTimeMillis() - timer >= 1000) {
				System.out.println("FPS: "+ frames);
				frames = 0;
				timer += 1000;
			}
		}
		stop();  //não obrigatório; Para parar as threads
	}

}
