package inicio_logica_games;

import java.util.ArrayList;  //Importando o ArrayList para adicionar infinitos elementos no array

public class Game implements Runnable{ //Interface Runnable permite trabalhar com threads
	
	private boolean isRunning; //se o Jogo ta rodando. Por padrão é falso
	private Thread thread;  //declarando minha thread do tipo Thread
	private ArrayList<Entidade> entidades = new ArrayList<>(); //  <Tipo_de_Classe> nome_var_guarda_lista
	
	public Game() {
		entidades.add(new Entidade());  //índice 0
		entidades.add(new Entidade());  //índice 1
		entidades.add(new Entidade());  //índice 2
		entidades.add(new Entidade());
		entidades.add(new Entidade());
		for(int i=0; i < entidades.size(); i++) {
			Entidade e = entidades.get(0);  //get(índice)
			e.vida = 100;
		}
		System.out.println(this);
		
	}
	public static void main(String[] args) {
		Game game = new Game();  //Instanciando classe game
		game.start();  //Para iniciar o Jogo
		
	}
	
	public synchronized void start() { //método sincronizado assim que chamar ele
		isRunning = true;  // Por padrão é false, mas como o jogo so roda se for true, atribuo o true aqui.
		thread = new Thread(this);  //Instanciando a minha Thread. Passando como parâmetro é a classa que eu quero que tenha a interface  Runnable, passo o Game através do this
		thread.start(); //Método Start() da Thread, vai pegar o método Run, que na verdade é uma thread.
	}

	public void atualizar() {  
		//Atualizar o Jogo.
		//System.out.println("Método Atualizar");
	}
	
	public void renderizar() {	
		//Renderizar o Jogo.
		//System.out.println("Método Renderizar");
	}
@Override
public void run() {  //THREAD, permite que os 2 métodos rodem simultaneamente dentro do loop
	
	while(isRunning) {
		atualizar();
		renderizar();
		
		/*try {                    //Gambiarra Jogos pequenos para 60fps
			Thread.sleep(1000/60);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		*/
		
	}
	
}

}
